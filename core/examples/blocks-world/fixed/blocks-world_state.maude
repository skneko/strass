mod BLOCKS-WORLD is 
    including INT .

    sorts Block Prop PropSet State .
    subsort Prop < PropSet < State .
    
    ops a b c : -> Block .
    op table : Block -> Prop . *** block is on the table
    op on : Block Block -> Prop . *** block A is on block B
    op clear : Block -> Prop . *** block is clear
    op hold : Block -> Prop . *** robot arm holds the block
    op empty : -> PropSet . *** robot arm is empty
    op none : -> PropSet .
    op _&_ : PropSet PropSet -> PropSet [ctor assoc comm id: none] .
    op [_] : PropSet -> State [ctor] .
    op size : Block -> Nat .

    vars X Y : Block .
    var PS : PropSet .

    eq [sizeA] : size(a) = 1 .
    eq [sizeB] : size(b) = 2 .
    eq [sizeC] : size(c) = 3 .

    rl [pickup] : [ clear(X) & table(X) & PS ] => [ hold(X) & PS ] .
    rl [putdown] : [ hold(X) & PS ] => [ empty & clear(X) & table(X) & PS ] .
    rl [unstack] : [ empty & clear(X) & on(X,Y) & PS ] => [ hold(X) & clear(Y) & PS ] .
    crl [stack] : [ hold(X) & clear(Y) & PS ] => [ empty & clear(X) & on(X,Y) & PS ] if size(X) < size(Y) .
endm

***(
	Generated by STRASS -- safe-tools.dsic.upv.es/strass
)

smod BLOCKS-WORLD-SAFE is
	protecting BLOCKS-WORLD .
	protecting EXT-BOOL .
	strat Block! : @ Block .
	strat Block* : @ Block .
	strat Block+ : @ Block .
	strat Block-state : @ Block .
	strat State! : @ State .
	strat State* : @ State .
	strat State+ : @ State .
	strat State-state : @ State .
	strat s1 : @ PropSet .
	strat s2 : @ Prop .
	strat s3 : @ PropSet .
	strat s4 : @ PropSet .
	strat s5 : @ PropSet .
	strat s6 : @ PropSet .
	strat s7 : @ PropSet .
	sd Block! := (all) ! .
	sd Block* := (all) * .
	sd Block+ := (all) + .
	sd Block-state := idle .
	sd State! := (State-state) ; (((all) ; (State-state)) !) .
	sd State* := (State-state) ; (((all) ; (State-state)) *) .
	sd State+ := (State-state) ; (((all) ; (State-state)) +) .
	sd State-state := (s2) ; ((s1) ; ((s3) ; ((s4) ; ((s5) ; ((s6) ; (s7)))))) .
	sd s1 := not(amatch on(X1:Block, X2:Block) & on(Y1:Block, Y2:Block) s.t. X1:Block =/= Y1:Block = false) .
	sd s2 := not(amatch on(X:Block, Y:Block) s.t. size(X:Block) < size(Y:Block) = false) .
	sd s3 := not(amatch on(X1:Block, X2:Block) & table(Y:Block) & table(Z:Block) s.t. X1:Block =/= Y:Block and-then X1:Block =/= Z:Block = false) .
	sd s4 := not(amatch hold(X:Block) & hold(Y:Block) s.t. true) .
	sd s5 := not(amatch empty & empty s.t. true) .
	sd s6 := not(amatch empty & hold(X:Block) s.t. true) .
	sd s7 := not(amatch table(X:Block) & hold(Y:Block) s.t. X:Block =/= Y:Block = false) .
endsm
