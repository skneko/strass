fmod TIME is
    protecting INT .

    sorts Time TimeOrInf Infinity .
    subsort Int < Time .
    subsorts Infinity Time < TimeOrInf .
    op +inf : -> Infinity .

    sort TimeInterval .
    op [_,_] : Time TimeOrInf -> TimeInterval [ctor] .

    var T : Time .
    
    eq +inf + T = +inf .
    eq +inf - T = +inf .
    eq T - +inf = +inf .
    eq +inf < T = false .
    eq +inf <= T = false .
    eq +inf >= T = true .
    eq +inf > T = true .
endfm

mod SATELLITE is
    protecting EXT-BOOL .
    protecting TIME .

    sorts PointingMode PointingModeState .
    ops earth slewing science comm maintenance : -> PointingMode [ctor] .
    op pm:__ : Time PointingMode -> PointingModeState [ctor format(m! oys os o)] .

    sort GroundVisibility GroundVisibilityState .
    ops visible notVisible : -> GroundVisibility [ctor] .
    op gv:__ : Time GroundVisibility -> GroundVisibilityState [ctor format(m! oys os o)] .

    sort InstrumentStatus InstrumentStatusState .
    ops idle warmup process turnoff : -> InstrumentStatus [ctor] .
    op is:__ : Time InstrumentStatus -> InstrumentStatusState [ctor format(m! oys os o)] .

    sort State .
    op {_,_,_} : PointingModeState GroundVisibilityState InstrumentStatusState -> State [ctor format(m os m s m s ms o)] .

    sort StateVariable .
    subsorts PointingMode GroundVisibility InstrumentStatus < StateVariable .

    op duration : StateVariable -> TimeInterval .
    eq duration(earth) = [ 1, +inf ] .
    eq duration(slewing) = [ 30, 30 ] .
    eq duration(science) = [ 36, 58 ] .
    eq duration(comm) = [ 30, 50 ] .
    eq duration(maintenance) = [ 90, 90 ] .
    eq duration(visible) = [ 60, 100 ] .
    eq duration(notVisible) = [ 1, 100 ] .
    eq duration(idle) = [ 1, +inf ] .
    eq duration(warmup) = [ 5, 5 ] .
    eq duration(process) = [ 5, 5 ] .
    eq duration(turnoff) = [ 5, 5 ] .

    vars T Tmin Tmax : Time . var V : StateVariable .

    op canContinue : Time TimeInterval -> Bool .
    eq canContinue(T, [ Tmin, Tmax ]) = T <= Tmax .
    eq canContinue(T, [ Tmin, +inf ]) = true .

    op canChange : Time TimeInterval -> Bool .
    eq canChange(T, [ Tmin, Tmax:TimeOrInf ]) = T >= Tmin .

    op canContinue : Time StateVariable -> Bool .
    eq canContinue(T, V) = canContinue(T, duration(V)) .

    op canChange : Time StateVariable -> Bool .
    eq canChange(T, V) = canChange(T, duration(V)) .

    vars Tpm Tgv Tis : Time . var PM : PointingMode . var GV : GroundVisibility . var IS : InstrumentStatus .

    crl [advance-time] : { pm: Tpm PM, gv: Tgv GV, is: Tis IS } => { pm: (Tpm + 1) PM, gv: (Tgv + 1) GV, is: (Tis + 1) IS }
        if canContinue(Tpm + 1, PM) and-then canContinue(Tgv + 1, GV) and-then canContinue(Tis + 1, IS) .

    crl [pm-earth-slewing] :        pm: T earth       => pm: 0 slewing     if canChange(T, earth) .
    crl [pm-earth-comm] :           pm: T earth       => pm: 0 comm        if canChange(T, earth) .
    crl [pm-earth-maintenance] :    pm: T earth       => pm: 0 maintenance if canChange(T, earth) .
    crl [pm-slewing-earth] :        pm: T slewing     => pm: 0 earth       if canChange(T, slewing) .
    crl [pm-slewing-science] :      pm: T slewing     => pm: 0 science     if canChange(T, slewing) .
    crl [pm-science-slewing] :      pm: T science     => pm: 0 slewing     if canChange(T, science) .
    crl [pm-comm-earth] :           pm: T comm        => pm: 0 earth       if canChange(T, comm) .
    crl [pm-comm-maintenance] :     pm: T comm        => pm: 0 maintenance if canChange(T, comm) .
    crl [pm-maintenance-earth] :    pm: T maintenance => pm: 0 earth       if canChange(T, comm) .

    crl [gv-visible-notVisible] :   gv: T visible     => gv: 0 notVisible  if canChange(T, visible) .
    crl [gv-notVisible-visible] :   gv: T notVisible  => gv: 0 visible     if canChange(T, notVisible) .

    crl [is-idle-warmup] :          is: T idle        => is: 0 warmup      if canChange(T, idle) .
    crl [is-idle-process] :         is: T idle        => is: 0 process     if canChange(T, idle) .
    crl [is-warmup-idle] :          is: T warmup      => is: 0 idle        if canChange(T, warmup) .
    crl [is-warmup-process] :       is: T warmup      => is: 0 process     if canChange(T, warmup) .
    crl [is-process-idle] :         is: T process     => is: 0 idle        if canChange(T, process) .
    crl [is-process-turnoff] :      is: T process     => is: 0 turnoff     if canChange(T, process) .
    crl [is-turnoff-idle] :         is: T turnoff     => is: 0 idle        if canChange(T, turnoff) .
endm

***(
	Generated by STRASS -- safe-tools.dsic.upv.es/strass
)

smod SATELLITE-SAFE is
	protecting SATELLITE .
	protecting EXT-BOOL .
	op max : TimeInterval -> Time .
	eq max([Tmin:Time, Tmax:Time]) = Tmax:Time .
	strat Bool! : @ Bool .
	strat Bool* : @ Bool .
	strat Bool+ : @ Bool .
	strat Bool-state : @ Bool .
	strat GroundVisibilityState! : @ GroundVisibilityState .
	strat GroundVisibilityState* : @ GroundVisibilityState .
	strat GroundVisibilityState+ : @ GroundVisibilityState .
	strat GroundVisibilityState-state : @ GroundVisibilityState .
	strat InstrumentStatusState! : @ InstrumentStatusState .
	strat InstrumentStatusState* : @ InstrumentStatusState .
	strat InstrumentStatusState+ : @ InstrumentStatusState .
	strat InstrumentStatusState-state : @ InstrumentStatusState .
	strat PointingModeState! : @ PointingModeState .
	strat PointingModeState* : @ PointingModeState .
	strat PointingModeState+ : @ PointingModeState .
	strat PointingModeState-state : @ PointingModeState .
	strat State! : @ State .
	strat State* : @ State .
	strat State+ : @ State .
	strat State-path : @ State .
	strat State-state : @ State .
	strat StateVariable! : @ StateVariable .
	strat StateVariable* : @ StateVariable .
	strat StateVariable+ : @ StateVariable .
	strat StateVariable-state : @ StateVariable .
	strat TimeInterval! : @ TimeInterval .
	strat TimeInterval* : @ TimeInterval .
	strat TimeInterval+ : @ TimeInterval .
	strat TimeInterval-state : @ TimeInterval .
	strat TimeOrInf! : @ TimeOrInf .
	strat TimeOrInf* : @ TimeOrInf .
	strat TimeOrInf+ : @ TimeOrInf .
	strat TimeOrInf-state : @ TimeOrInf .
	strat s1 : @ Time .
	strat s2 : @ State .
	strat s3 : @ State .
	strat s4 : @ State .
	strat s5 : @ State .
	sd Bool! := (Bool-state) ; (((all) ; (Bool-state)) !) .
	sd Bool* := (Bool-state) ; (((all) ; (Bool-state)) *) .
	sd Bool+ := (Bool-state) ; (((all) ; (Bool-state)) +) .
	sd Bool-state := s1 .
	sd GroundVisibilityState! := (GroundVisibilityState-state) ; (((all) ; (GroundVisibilityState-state)) !) .
	sd GroundVisibilityState* := (GroundVisibilityState-state) ; (((all) ; (GroundVisibilityState-state)) *) .
	sd GroundVisibilityState+ := (GroundVisibilityState-state) ; (((all) ; (GroundVisibilityState-state)) +) .
	sd GroundVisibilityState-state := s1 .
	sd InstrumentStatusState! := (InstrumentStatusState-state) ; (((all) ; (InstrumentStatusState-state)) !) .
	sd InstrumentStatusState* := (InstrumentStatusState-state) ; (((all) ; (InstrumentStatusState-state)) *) .
	sd InstrumentStatusState+ := (InstrumentStatusState-state) ; (((all) ; (InstrumentStatusState-state)) +) .
	sd InstrumentStatusState-state := s1 .
	sd PointingModeState! := (PointingModeState-state) ; (((all) ; (PointingModeState-state)) !) .
	sd PointingModeState* := (PointingModeState-state) ; (((all) ; (PointingModeState-state)) *) .
	sd PointingModeState+ := (PointingModeState-state) ; (((all) ; (PointingModeState-state)) +) .
	sd PointingModeState-state := s1 .
	sd State! := (State-state) ; ((State-path) !) .
	sd State* := (State-state) ; ((State-path) *) .
	sd State+ := (State-state) ; ((State-path) +) .
	sd State-path := ((idle) | ((gv-notVisible-visible) ; (State-state)) | ((gv-visible-notVisible) ; (State-state)) | ((is-idle-process) ; (State-state)) | ((is-idle-warmup) ; (State-state)) | ((is-process-idle) ; (State-state)) | ((is-process-turnoff) ; (State-state)) | ((is-turnoff-idle) ; (State-state)) | ((is-warmup-idle) ; (State-state)) | ((is-warmup-process) ; (State-state)) | ((pm-comm-earth) ; (State-state)) | ((pm-comm-maintenance) ; (State-state)) | ((pm-earth-comm) ; (State-state)) | ((pm-earth-maintenance) ; (State-state)) | ((pm-earth-slewing) ; (State-state)) | ((pm-maintenance-earth) ; (State-state)) | ((pm-science-slewing) ; (State-state)) | ((pm-slewing-earth) ; (State-state)) | (pm-slewing-science) ; (State-state)) ; ((advance-time) ; (State-state)) .
	sd State-state := (s2) ; ((s3) ; ((s4) ; ((s5) ; (s1)))) .
	sd StateVariable! := (all) ! .
	sd StateVariable* := (all) * .
	sd StateVariable+ := (all) + .
	sd StateVariable-state := idle .
	sd TimeInterval! := (TimeInterval-state) ; (((all) ; (TimeInterval-state)) !) .
	sd TimeInterval* := (TimeInterval-state) ; (((all) ; (TimeInterval-state)) *) .
	sd TimeInterval+ := (TimeInterval-state) ; (((all) ; (TimeInterval-state)) +) .
	sd TimeInterval-state := s1 .
	sd TimeOrInf! := (TimeOrInf-state) ; (((all) ; (TimeOrInf-state)) !) .
	sd TimeOrInf* := (TimeOrInf-state) ; (((all) ; (TimeOrInf-state)) *) .
	sd TimeOrInf+ := (TimeOrInf-state) ; (((all) ; (TimeOrInf-state)) +) .
	sd TimeOrInf-state := s1 .
	sd s1 := not(amatch T:Time s.t. T:Time >= 0 = false) .
	sd s2 := not(amatch {pm: Tpm:Time comm, gv: Tgv:Time GV:GroundVisibility, is: Tis:Time IS:InstrumentStatus} s.t. GV:GroundVisibility == visible = false) .
	sd s3 := not(amatch {pm: Tpm:Time maintenance, gv: Tgv:Time GV:GroundVisibility, is: Tis:Time IS:InstrumentStatus} s.t. IS:InstrumentStatus == idle = false) .
	sd s4 := not(amatch {pm: Tpm:Time maintenance, gv: Tgv:Time notVisible, is: Tis:Time IS:InstrumentStatus} s.t. true) .
	sd s5 := not(amatch {pm: Tpm:Time science, gv: Tgv:Time GV:GroundVisibility, is: Tis:Time idle} s.t. Tis:Time <= 2 * max(duration(process)) = false) .
endsm
