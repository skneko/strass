mod PHILO is
    protecting NAT .
    
    sorts Philo Status Chopstick Conf PState .
    subsorts Philo Chopstick < Conf .

    op ph : Nat Status Nat -> Philo [ctor] .
    ops think hungry : -> Status [ctor] .
    op stk : Nat -> Chopstick [ctor] .
    op none : -> Conf [ctor] .
    op _;_ : Conf Conf -> Conf [ctor comm assoc id: none] .
    op <_`,_`,_> : Nat Nat Conf -> PState [ctor] .
    op left : Nat -> Nat .
    op right : Nat Nat -> Nat .
    op collatz : Nat -> Nat .
    
    vars P N C : Nat .
    vars I J : NzNat .
    vars CF : Conf .
    
    eq left(I) = I .
    eq right(I, N) = s(I rem N) .
    eq collatz(P) = if P rem 2 == 0 then (P quo 2) else (3 * P + 1) fi .

    rl [wake] : < P, N, ph(I, think, 0) ; CF > => < P, N, ph(I, hungry, 0) ; CF > .
    crl [grab] : < P, N, ph(I, hungry, C) ; stk(J) ; CF > => < P, N, ph(I, hungry, C + 1) ; CF > if J == left(I) or J == right(I, N) .
    rl [stop] : < P, N, ph(I, hungry, 2) ; CF > => < P, N, ph(I, think, 0) ; stk(left(I)) ; stk(right(I, N)) ; CF > .
    crl [solve] : < P, N, ph(I, think, 0) ; CF > => < collatz(P), N, ph(I, think, 0) ; CF > if P > 1 .
    crl [join] : < P, N, ph(N, think, 0) ; CF > => < P, N + 1, ph(N, think, 0) ; ph(N + 1, think, 0) ; stk(N + 1) ; CF > if (P rem (4 * N) == 0) or (N rem 3 == 0) .
    crl [leave] : < P, N, CF ; ph(N, think, 0) ; stk(N) > => < P, sd(N, 1), CF > if N > 2 .
endm 

***(
	Generated by STRASS -- safe-tools.dsic.upv.es/strass
)

smod PHILO-SAFE is
	protecting PHILO .
	protecting EXT-BOOL .
	strat Bool! : @ Bool .
	strat Bool* : @ Bool .
	strat Bool+ : @ Bool .
	strat Bool-state : @ Bool .
	strat Conf! : @ Conf .
	strat Conf* : @ Conf .
	strat Conf+ : @ Conf .
	strat Conf-state : @ Conf .
	strat Nat! : @ Nat .
	strat Nat* : @ Nat .
	strat Nat+ : @ Nat .
	strat Nat-state : @ Nat .
	strat PState! : @ PState .
	strat PState* : @ PState .
	strat PState+ : @ PState .
	strat PState-state : @ PState .
	strat Status! : @ Status .
	strat Status* : @ Status .
	strat Status+ : @ Status .
	strat Status-state : @ Status .
	strat s1 : @ PState .
	strat s2 : @ PState .
	strat s3 : @ Nat .
	sd Bool! := (Bool-state) ; (((all) ; (Bool-state)) !) .
	sd Bool* := (Bool-state) ; (((all) ; (Bool-state)) *) .
	sd Bool+ := (Bool-state) ; (((all) ; (Bool-state)) +) .
	sd Bool-state := s3 .
	sd Conf! := (Conf-state) ; (((all) ; (Conf-state)) !) .
	sd Conf* := (Conf-state) ; (((all) ; (Conf-state)) *) .
	sd Conf+ := (Conf-state) ; (((all) ; (Conf-state)) +) .
	sd Conf-state := s3 .
	sd Nat! := (Nat-state) ; (((all) ; (Nat-state)) !) .
	sd Nat* := (Nat-state) ; (((all) ; (Nat-state)) *) .
	sd Nat+ := (Nat-state) ; (((all) ; (Nat-state)) +) .
	sd Nat-state := s3 .
	sd PState! := (PState-state) ; (((all) ; (PState-state)) !) .
	sd PState* := (PState-state) ; (((all) ; (PState-state)) *) .
	sd PState+ := (PState-state) ; (((all) ; (PState-state)) +) .
	sd PState-state := (s3) ; ((s1) ; (s2)) .
	sd Status! := (all) ! .
	sd Status* := (all) * .
	sd Status+ := (all) + .
	sd Status-state := idle .
	sd s1 := not(amatch < P:Nat, N:Nat, CF:Conf ; ph(I:NzNat, hungry, 2) > s.t. N:Nat >= 0 = false) .
	sd s2 := not(amatch < P:Nat, N:Nat, CF:Conf ; ph(I:NzNat, think, 0) > s.t. I:NzNat > 0 = false) .
	sd s3 := not(amatch collatz(P:Nat) s.t. P:Nat >= 0 = false) .
endsm
